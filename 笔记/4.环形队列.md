## 介绍

我们在队列的基础上进行修改

front初始值变成0，直接指向第一个元素

rear指向最后一个元素的后一个位置

|     队列数据      |  100  | 200  | 300  |      |      |      |      |
| :---------------: | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|     队列下标      |   0   |  1   |  2   |  3   |  4   |  5   |  6   |
| front所指向的位置 | front |      |      |      |      |      |      |
| rear所指向的位置  |       |      |      | rear |      |      |      |

判断队伍满 （rear + 1）% maxSize = front

就是rear+1与队列总数取模是否等于front，如果rear+1等于maxSize，代表指向了最后一个元素了，要指回队列的第一个位置了，取模一下就是0了，这样就能达到循环判断的目的



判断队伍空就是 rear = front



判断队列存了多少个数据 （rear + maxSize - front）% maxSize

还是rear有可能为0，而front不为0这种情况，如果rear = 1，而front = 3，maxSize = 7

如果单纯用rear - front已经无法满足

|     队列数据      | 100  |      |      |  400  | 500  | 600  | 700  |
| :---------------: | :--: | :--: | :--: | :---: | :--: | :--: | :--: |
|     队列下标      |  0   |  1   |  2   |   3   |  4   |  5   |  6   |
| front所指向的位置 |      |      |      | front |      |      |      |
| rear所指向的位置  |      | rear |      |       |      |      |      |

所以我们得到这个公式rear + maxSize - front，和上面的相结合，就是（rear + maxSize - front）% maxSize

